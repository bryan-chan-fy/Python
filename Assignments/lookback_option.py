import numpy as np
from scipy.stats import norm

class lookback_option:
    '''define a class to store common option data and function definition'''
    ## if call_or_put == 1, means call option, else, put option.
    
    def __init__(self, call_or_put, maturity, spot_price, sigma, risk_free_rate, strike_price, dividends):
        self.I = call_or_put
        self.T = maturity
        self.S0 = spot_price 
        self.sigma = sigma
        self.r = risk_free_rate
        self.K = strike_price
        self.q = dividends
    
    ## -------------------------------------- BT floating ----------------------------------------- ##
    ## unlike the underlying tree created before, this time we generate the tree by (N+1) lists
    ## i(0, N) list has 2**i nodes. each pair nodes are generated by last one node in last layer.
    ## the nodes which have the same underlying price are not merge to one nodes (important)
    ## each node has two value to store, the currenct price and the max spot price before.
    def floating_underlying_price_tree(self, N):
        '''input: the option and the number of periods'''
        '''output: the binomial tree of the underlying price (N+1 * 2**(N) * 2 array)'''
        
        ## parameter initializing
        dt, u = self.T/N, np.exp(self.sigma*np.sqrt(self.T/N))
        d = 1/u; p = (np.exp((self.r-self.q)*dt)-d)/(u-d)
        
        underlying_tree = np.zeros([2**N,N+1,2])
        
        
        underlying_tree[0,0,0] = self.S0
        underlying_tree[0,0,1] = self.S0
        

        if self.I == 0 :
            for i in range(1,N+1):
                for j in range(2**i):
                    if j % 2 == 0:
                        underlying_tree[j,i,0] = round(underlying_tree[int(j/2),i-1,0]*u,2)
                        underlying_tree[j,i,1] = max(underlying_tree[j,i,0], underlying_tree[int(j/2),i-1,1])
                    else:
                        underlying_tree[j,i,0] = round(underlying_tree[int((j-1)/2),i-1,0]*d,2)
                        underlying_tree[j,i,1] = underlying_tree[int((j-1)/2),i-1,1]
        
        else: 
            for i in range(1,N+1):
                for j in range(2**i):
                    if j % 2 == 0:
                        underlying_tree[j,i,0] = round(underlying_tree[int(j/2),i-1,0]*u,2)
                        underlying_tree[j,i,1] = min(underlying_tree[j,i,0], underlying_tree[int(j/2),i-1,1])
                    else:
                        underlying_tree[j,i,0] = round(underlying_tree[int((j-1)/2),i-1,0]*d,2)
                        underlying_tree[j,i,1] = min(underlying_tree[j,i,0], underlying_tree[int(j/2),i-1,1])
                        
                        
        return underlying_tree
        
    # <--- TRIAL
    def floating_underlying_price_tree_0(self, N):
        
        ## parameter initializing
        dt, u = self.T/N, np.exp(self.sigma*np.sqrt(self.T/N))
        d = 1/u; p = (np.exp((self.r-self.q)*dt)-d)/(u-d)
        print('p ',p,'u ',u,'dt ',dt)
        
        # compute list size
        list_size=int(np.floor(N)/2+1)
        temp_list=np.zeros(list_size)
        print('list size',list_size)
        
        # underlying_tree_0[j,i,0] index 0 store underlying price
        # underlying tree_0[j,i,1:] index 1 onwards store max or min
        underlying_tree_0= np.zeros([N+1,N+1,list_size+1])
        underlying_tree_0[0,0,0] = self.S0
        underlying_tree_0[0,0,1]= self.S0    # first max or min list item
        underlying_tree_0[0,0,2:]=0        
        
        # check if element exist in array
        def checkif_exist(array_,element):
            exist=0
            for n in range(len(array_)):
                if array_[n]==element:
                    exist=1
            return exist
        
        # check the next available index of empty slots in array
        def fnext_index(array_):
            index_=-1
            for n in range(len(array_)):
                if array_[n]==0:
                    index_=n
                    break
            return index_
                    
        # put option, max list
        if self.I == 0:
            for i in range(1,N+1):
                for j in range(i+1):
                    # generate underlying price for tree
                    if j==0:
                        underlying_tree_0[j,i,0] = round(underlying_tree_0[int(j),i-1,0]*u,2)
                    else:
                        underlying_tree_0[j,i,0] = round(underlying_tree_0[int(j-1),i-1,0]*d,2)                           
                    # if not lowest branch
                    if j!=i:
                        cnt=fnext_index(underlying_tree_0[j,i,1:])+1
                        cnt_old=cnt
                        # add max list items from prev lower left branch if >= cur price
                        for k in range(1,list_size+1):
                            if underlying_tree_0[j,i-1,k]!=0 and underlying_tree_0[j,i-1,k]>=underlying_tree_0[j,i,0]:
                                if checkif_exist(underlying_tree_0[j,i,1:],underlying_tree_0[j,i-1,k])==0:
                                    underlying_tree_0[j,i,cnt]=underlying_tree_0[j,i-1,k]
                                    cnt+=1
                        # add cur price to list if none was added from prev lower left list (i.e. highest price)
                        if cnt==cnt_old:
                            underlying_tree_0[j,i,cnt]=underlying_tree_0[j,i,0]
                            cnt+=1
                    # if not highest branch
                    if j>=1:
                        cnt=fnext_index(underlying_tree_0[j,i,1:])+1
                        # add max list items from prev upper left branch if >= cur price
                        for k in range(1,list_size+1):
                            if underlying_tree_0[j-1,i-1,k]!=0 and underlying_tree_0[j-1,i-1,k]>=underlying_tree_0[j,i,0]:
                                if checkif_exist(underlying_tree_0[j,i,1:],underlying_tree_0[j-1,i-1,k])==0:   
                                     underlying_tree_0[j,i,cnt]=underlying_tree_0[j-1,i-1,k]
                                     cnt+=1
        # call option, min list
        else:
            for i in range(1,N+1):
                for j in range(i+1):
                    # generate underlying price for tree
                    if j==0:
                        underlying_tree_0[j,i,0] = round(underlying_tree_0[int(j),i-1,0]*u,2)
                    else:
                        underlying_tree_0[j,i,0] = round(underlying_tree_0[int(j-1),i-1,0]*d,2)           
                    # if not lowest branch
                    if j!=i:
                        cnt=fnext_index(underlying_tree_0[j,i,1:])+1
                        # add min list items from prev lower left branch if <= cur price
                        for k in range(1,list_size+1):
                            if underlying_tree_0[j,i-1,k]!=0 and underlying_tree_0[j,i-1,k]<=underlying_tree_0[j,i,0]:
                                if checkif_exist(underlying_tree_0[j,i,1:],underlying_tree_0[j,i-1,k])==0:
                                    underlying_tree_0[j,i,cnt]=underlying_tree_0[j,i-1,k]
                                    cnt+=1
                    # if not highest branch
                    if j>=1:
                        cnt=fnext_index(underlying_tree_0[j,i,1:])+1
                        cnt_old=cnt
                        # add min list items from prev upper left branch if <= cur price
                        for k in range(1,list_size+1):
                            if underlying_tree_0[j-1,i-1,k]!=0 and underlying_tree_0[j-1,i-1,k]<=underlying_tree_0[j,i,0]:
                                if checkif_exist(underlying_tree_0[j,i,1:],underlying_tree_0[j-1,i-1,k])==0:   
                                     underlying_tree_0[j,i,cnt]=underlying_tree_0[j-1,i-1,k]
                                     cnt+=1
                        # add cur price to list if none was added from prev upper left list (i.e. lowest price)
                        if cnt==cnt_old and cnt==1:
                            underlying_tree_0[j,i,cnt]=underlying_tree_0[j,i,0]
                            cnt+=1
        # sort the list at each node from high to low
        for i in range(1,N+1):
                for j in range(i+1):
                    temp_list=sorted(underlying_tree_0[j,i,1:],reverse=True)
                    underlying_tree_0[j,i,1:]=temp_list
                    
        return underlying_tree_0
    #--->

    # <--- TRIAL
    def floating_underlying_price_tree_1(self, N):
        
        ## parameter initializing
        dt, u = self.T/N, np.exp(self.sigma*np.sqrt(3*self.T/N))
        d = 1/u; p = (np.exp((self.r-self.q)*dt)-d)/(u-d)
        p_d = - (np.sqrt(dt/(12*self.sigma*self.sigma)))*(self.r-self.q-0.5*self.sigma*self.sigma) + 1/6
        p_m = 2/3; p_u = (np.sqrt(dt/(12*self.sigma*self.sigma)))*(self.r-self.q-0.5*self.sigma*self.sigma) + 1/6
        
        print('p ',p,'u ',u,'dt ',dt)
        print('p_u',p_u,'p_m',p_m,'p_d',p_d)
        
        # compute list size
        list_size=int(np.floor(N)/2+1)
        temp_list=np.zeros(list_size)
        print('list size',list_size)
        
        # underlying_tree_0[j,i,0] index 0 store underlying price
        # underlying tree_0[j,i,1:] index 1 onwards store max or min
        underlying_tree_1= np.zeros([2*N+1,N+1,list_size+1])
        underlying_tree_1[N,:,0] = self.S0
        underlying_tree_1[N,0,1]= self.S0    # first max or min list item
        underlying_tree_1[0,0,2:]=0        
        
        # check if element exist in array
        def checkif_exist(array_,element):
            exist=0
            for n in range(len(array_)):
                if array_[n]==element:
                    exist=1
            return exist
        
        # check the next available index of empty slots in array
        def fnext_index(array_):
            index_=-1
            for n in range(len(array_)):
                if array_[n]==0:
                    index_=n
                    break
            return index_
        
        # generate underlying price for tree first
        for i in range(1,N+1):
            for j in range(1,i+1):
                underlying_tree_1[N-j,i,0] = round(underlying_tree_1[N+1-j, i-1,0]*u,2)
                underlying_tree_1[N+j,i,0] = round(underlying_tree_1[N-1+j, i-1,0]*d,2)    
    
        # put option, max list
        if self.I == 0:
            for i in range(1,N+1):
                for j in range(N-i,N+i+1):
                    cnt=fnext_index(underlying_tree_1[j,i,1:])+1
                    cnt_old=cnt
                    # if not lowest branch and 2nd lowest branch                   
                    if j<N+i-1:
                        cnt=fnext_index(underlying_tree_1[j,i,1:])+1
                        # add max list items from prev lower left branch if >= cur price
                        for k in range(1,list_size+1):
                            if underlying_tree_1[j+1,i-1,k]!=0 and underlying_tree_1[j+1,i-1,k]>=underlying_tree_1[j,i,0]:
                                if checkif_exist(underlying_tree_1[j,i,1:],underlying_tree_1[j+1,i-1,k])==0:
                                    underlying_tree_1[j,i,cnt]=underlying_tree_1[j+1,i-1,k]
                                    cnt+=1
                    # if not the lowest branch or highest branch
                    if j!=N+i or j!=N-i:
                        # add max list items from prev middle left branch if >= cur price
                        for k in range(1,list_size+1):
                            if underlying_tree_1[j,i-1,k]!=0 and underlying_tree_1[j,i-1,k]>=underlying_tree_1[j,i,0]:
                                if checkif_exist(underlying_tree_1[j,i,1:],underlying_tree_1[j,i-1,k])==0:
                                    underlying_tree_1[j,i,cnt]=underlying_tree_1[j,i-1,k]
                                    cnt+=1                
                    # if not highest branch and 2nd highest branch
                    if j>N-i+1:
                        # add max list items from prev upper left branch if >= cur price
                        for k in range(1,list_size+1):
                            if underlying_tree_1[j-1,i-1,k]!=0 and underlying_tree_1[j-1,i-1,k]>=underlying_tree_1[j,i,0]:
                                if checkif_exist(underlying_tree_1[j,i,1:],underlying_tree_1[j-1,i-1,k])==0:   
                                     underlying_tree_1[j,i,cnt]=underlying_tree_1[j-1,i-1,k]
                                     cnt+=1
                    # add cur price to list if none was added from prev nodes list (i.e. highest price)
                    if cnt==cnt_old:
                        underlying_tree_1[j,i,cnt]=underlying_tree_1[j,i,0]
                        cnt+=1                
#    
        else:
            for i in range(1,N+1):
                for j in range(N-i,N+i+1):
                    cnt=fnext_index(underlying_tree_1[j,i,1:])+1
                    cnt_old=cnt
                    # if not lowest branch and 2nd lowest branch                   
                    if j<N+i-1:
                        cnt=fnext_index(underlying_tree_1[j,i,1:])+1
                        # add min list items from prev lower left branch if <= cur price
                        for k in range(1,list_size+1):
                            if underlying_tree_1[j+1,i-1,k]!=0 and underlying_tree_1[j+1,i-1,k]<=underlying_tree_1[j,i,0]:
                                if checkif_exist(underlying_tree_1[j,i,1:],underlying_tree_1[j+1,i-1,k])==0:
                                    underlying_tree_1[j,i,cnt]=underlying_tree_1[j+1,i-1,k]
                                    cnt+=1
                    # if not the lowest branch or highest branch
                    if j!=N+i or j!=N-i:
                        # add min list items from prev middle left branch if <= cur price
                        for k in range(1,list_size+1):
                            if underlying_tree_1[j,i-1,k]!=0 and underlying_tree_1[j,i-1,k]<=underlying_tree_1[j,i,0]:
                                if checkif_exist(underlying_tree_1[j,i,1:],underlying_tree_1[j,i-1,k])==0:
                                    underlying_tree_1[j,i,cnt]=underlying_tree_1[j,i-1,k]
                                    cnt+=1                
                    # if not highest branch and 2nd highest branch
                    if j>N-i+1:
                        # add min list items from prev upper left branch if <= cur price
                        for k in range(1,list_size+1):
                            if underlying_tree_1[j-1,i-1,k]!=0 and underlying_tree_1[j-1,i-1,k]<=underlying_tree_1[j,i,0]:
                                if checkif_exist(underlying_tree_1[j,i,1:],underlying_tree_1[j-1,i-1,k])==0:   
                                     underlying_tree_1[j,i,cnt]=underlying_tree_1[j-1,i-1,k]
                                     cnt+=1
                    # add cur price to list if none was added from prev nodes list (i.e. lowest price)
                    if cnt==cnt_old and cnt==1:
                        underlying_tree_1[j,i,cnt]=underlying_tree_1[j,i,0]
                        cnt+=1
        # sort the list at each node from high to low
        for i in range(1,N+1):
                for j in range(N-i,N+i+1):
                    temp_list=sorted(underlying_tree_1[j,i,1:],reverse=True)
                    underlying_tree_1[j,i,1:]=temp_list
                    
        return underlying_tree_1
    #--->

    
    def floating_EU_option_tree(self, N):
        underlying_tree = self.floating_underlying_price_tree(N)
        option_tree = np.zeros([2**N, N+1])
        
        dt, u = self.T/N, np.exp(self.sigma*np.sqrt(self.T/N))
        d = 1/u; p = (np.exp((self.r-self.q)*dt)-d)/(u-d)
        
        option_tree[:,N] = np.maximum(np.zeros(2**N),(1-2*self.I)* (underlying_tree[:,N,1] - underlying_tree[:,N,0]))
        for i in np.arange(N-1,-1,-1):
            for j in np.arange(0,2**i):
                option_tree[j,i]=np.exp(-self.r*dt)*(p*option_tree[2*j,i+1]+(1-p)*option_tree[2*j+1,i+1])
        
        return np.round(option_tree,2)
    
    # <--- TRIAL
    def floating_EU_option_tree_0(self, N):
        list_size=int(np.floor(N)/2+1)
        underlying_tree_0 = self.floating_underlying_price_tree_0(N)
        option_tree_0 = np.zeros([N+1, N+1,list_size+1])
        
        dt, u = self.T/N, np.exp(self.sigma*np.sqrt(self.T/N))
        d = 1/u; p = (np.exp((self.r-self.q)*dt)-d)/(u-d)
        
        # put option, max list            
        if self.I==0:
            for i in np.arange(N-1,-1,-1):
                for j in np.arange(0,i+1):
                    # N-1 tree nodes
                    if i==N-1:        
                        for k in range(1,list_size+1):
                            if underlying_tree_0[j,i,k]!=0:  
                                # compare i list with i+1 list, match found then calc. payoff
                                for m in range(1,list_size+1):
                                    if underlying_tree_0[j,i,k]==underlying_tree_0[j,i+1,m]:
                                        up_payoff=underlying_tree_0[j,i+1,m]-underlying_tree_0[j,i+1,0]
                                    if round(underlying_tree_0[j,i,k]*u,2)==underlying_tree_0[j,i+1,m] and underlying_tree_0[j,i,k]==underlying_tree_0[j,i,0]:
                                        up_payoff=round(underlying_tree_0[j,i,0]*u,2)-underlying_tree_0[j,i+1,0]
                                    if underlying_tree_0[j,i,k]==underlying_tree_0[j+1,i+1,m]:
                                        down_payoff=underlying_tree_0[j,i,k]-underlying_tree_0[j+1,i+1,0]
                                # store cur i payoff in option_tree_0
                                option_tree_0[j,i,k]=np.exp(-self.r*dt)*((p*up_payoff)+(1-p)*down_payoff)
                    # tree nodes before N-1
                    else:
                        for k in range(1,list_size+1):
                            if underlying_tree_0[j,i,k]!=0:
                                # compare i list with i+1 list, match found then extract i+1 payoff
                                for m in range(1,list_size+1):
                                    if underlying_tree_0[j,i,k]==underlying_tree_0[j,i+1,m]:
                                        up_payoff=option_tree_0[j,i+1,m]
                                    if round(underlying_tree_0[j,i,k]*u,2)==underlying_tree_0[j,i+1,m] and underlying_tree_0[j,i,k]==underlying_tree_0[j,i,0]:
                                        up_payoff=option_tree_0[j,i+1,m]
                                    if underlying_tree_0[j,i,k]==underlying_tree_0[j+1,i+1,m]:
                                        down_payoff=option_tree_0[j+1,i+1,m]
                                # store cur i payoff in option_tree_0
                                option_tree_0[j,i,k]=np.exp(-self.r*dt)*((p*up_payoff)+(1-p)*down_payoff)
        # call option, min list
        else:
            for i in np.arange(N-1,-1,-1):
                for j in np.arange(0,i+1):
                    # N-1 tree nodes
                    if i==N-1:        
                        for k in range(1,list_size+1):
                            if underlying_tree_0[j,i,k]!=0:  
                                # compare i list with i+1 list, match found then calc. payoff
                                for m in range(1,list_size+1):
                                    if underlying_tree_0[j,i,k]==underlying_tree_0[j+1,i+1,m]:
                                        down_payoff=underlying_tree_0[j+1,i+1,0]-underlying_tree_0[j+1,i+1,m]
                                    if round(underlying_tree_0[j,i,k]*d,2)==underlying_tree_0[j+1,i+1,m] and underlying_tree_0[j,i,k]==underlying_tree_0[j,i,0]:
                                        down_payoff=underlying_tree_0[j+1,i+1,0]-round(underlying_tree_0[j,i,0]*d,2)
                                    if underlying_tree_0[j,i,k]==underlying_tree_0[j,i+1,m]:
                                        up_payoff=underlying_tree_0[j,i+1,0]-underlying_tree_0[j,i,k]
                                # store cur i payoff in option_tree_0
                                option_tree_0[j,i,k]=np.exp(-self.r*dt)*((p*up_payoff)+(1-p)*down_payoff)
                    # tree nodes before N-1
                    else:
                        for k in range(1,list_size+1):
                            if underlying_tree_0[j,i,k]!=0:
                                # compare i list with i+1 list, match found then extract i+1 payoff
                                for m in range(1,list_size+1):
                                    if underlying_tree_0[j,i,k]==underlying_tree_0[j+1,i+1,m]:
                                        down_payoff=option_tree_0[j+1,i+1,m]
                                    if round(underlying_tree_0[j,i,k]*d,2)==underlying_tree_0[j+1,i+1,m] and underlying_tree_0[j,i,k]==underlying_tree_0[j,i,0]:
                                        down_payoff=option_tree_0[j+1,i+1,m]
                                    if underlying_tree_0[j,i,k]==underlying_tree_0[j,i+1,m]:
                                        up_payoff=option_tree_0[j,i+1,m]
                                # store cur i payoff in option_tree_0
                                option_tree_0[j,i,k]=np.exp(-self.r*dt)*((p*up_payoff)+(1-p)*down_payoff)
                                
        return np.round(option_tree_0,2)
    # <--- TRIAL
    def floating_EU_option_tree_1(self, N):
        list_size=int(np.floor(N)/2+1)
        underlying_tree_1 = self.floating_underlying_price_tree_1(N)
        option_tree_1 = np.zeros([2*N+1, N+1,list_size+1])
        
        #dt, u = self.T/N, np.exp(self.sigma*np.sqrt(self.T/N))
        #d = 1/u; p = (np.exp((self.r-self.q)*dt)-d)/(u-d)
        dt, u = self.T/N, np.exp(self.sigma*np.sqrt(3*self.T/N))
        d = 1/u; p = (np.exp((self.r-self.q)*dt)-d)/(u-d)
        p_d = - (np.sqrt(dt/(12*self.sigma*self.sigma)))*(self.r-self.q-0.5*self.sigma*self.sigma) + 1/6
        p_m = 2/3; p_u = (np.sqrt(dt/(12*self.sigma*self.sigma)))*(self.r-self.q-0.5*self.sigma*self.sigma) + 1/6
        
        # put option, max list            
        if self.I==0:
            for i in np.arange(N-1,-1,-1):
                for j in np.arange(N-i,N+i+1):
                    # N-1 tree nodes
                    if i==N-1:        
                        for k in range(1,list_size+1):
                            if underlying_tree_1[j,i,k]!=0:  
                                # compare i list with i+1 list, match found then calc. payoff
                                for m in range(1,list_size+1):
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j-1,i+1,m]:
                                        up_payoff=underlying_tree_1[j-1,i+1,m]-underlying_tree_1[j-1,i+1,0]
                                    if round(underlying_tree_1[j,i,k]*u,2)==underlying_tree_1[j-1,i+1,m] and underlying_tree_1[j,i,k]==underlying_tree_1[j,i,0]:
                                        up_payoff=round(underlying_tree_1[j,i,0]*u,2)-underlying_tree_1[j-1,i+1,0]
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j,i+1,m]:
                                        mid_payoff=underlying_tree_1[j,i+1,m]-underlying_tree_1[j,i+1,0]
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j+1,i+1,m]:
                                        down_payoff=underlying_tree_1[j,i,k]-underlying_tree_1[j+1,i+1,0]
                                # store cur i payoff in option_tree_1
                                option_tree_1[j,i,k]=np.exp(-self.r*dt)*(p_u*up_payoff+p_m*mid_payoff+p_d*down_payoff)
                    # tree nodes before N-1
                    else:
                        for k in range(1,list_size+1):
                            if underlying_tree_1[j,i,k]!=0:
                                # compare i list with i+1 list, match found then extract i+1 payoff
                                for m in range(1,list_size+1):
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j-1,i+1,m]:
                                        up_payoff=option_tree_1[j-1,i+1,m]
                                    if round(underlying_tree_1[j,i,k]*u,2)==underlying_tree_1[j-1,i+1,m] and underlying_tree_1[j,i,k]==underlying_tree_1[j,i,0]:
                                        up_payoff=option_tree_1[j-1,i+1,m]
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j,i+1,m]:
                                        mid_payoff=option_tree_1[j,i+1,m]
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j+1,i+1,m]:
                                        down_payoff=option_tree_1[j+1,i+1,m]
                                # store cur i payoff in option_tree_1
                                option_tree_1[j,i,k]=np.exp(-self.r*dt)*(p_u*up_payoff+p_m*mid_payoff+p_d*down_payoff)
        # call option, min list
        else:
            for i in np.arange(N-1,-1,-1):
                for j in np.arange(N-i,N+i+1):
                    # N-1 tree nodes
                    if i==N-1:        
                        for k in range(1,list_size+1):
                            if underlying_tree_1[j,i,k]!=0:  
                                # compare i list with i+1 list, match found then calc. payoff
                                for m in range(1,list_size+1):
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j+1,i+1,m]:
                                        down_payoff=underlying_tree_1[j+1,i+1,0]-underlying_tree_1[j+1,i+1,m]
                                    if round(underlying_tree_1[j,i,k]*d,2)==underlying_tree_1[j+1,i+1,m] and underlying_tree_1[j,i,k]==underlying_tree_1[j,i,0]:
                                        down_payoff=underlying_tree_1[j+1,i+1,0]-round(underlying_tree_1[j,i,0]*d,2)
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j,i+1,m]:
                                        mid_payoff=underlying_tree_1[j,i+1,0]-underlying_tree_1[j,i+1,m]
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j-1,i+1,m]:
                                        up_payoff=underlying_tree_1[j-1,i+1,0]-underlying_tree_1[j,i,k]
                                # store cur i payoff in option_tree_1
                                option_tree_1[j,i,k]=np.exp(-self.r*dt)*(p_u*up_payoff+p_m*mid_payoff+p_d*down_payoff)
                    # tree nodes before N-1
                    else:
                        for k in range(1,list_size+1):
                            if underlying_tree_1[j,i,k]!=0:
                                # compare i list with i+1 list, match found then extract i+1 payoff
                                for m in range(1,list_size+1):
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j+1,i+1,m]:
                                        down_payoff=option_tree_1[j+1,i+1,m]
                                    if round(underlying_tree_1[j,i,k]*d,2)==underlying_tree_1[j+1,i+1,m] and underlying_tree_1[j,i,k]==underlying_tree_1[j,i,0]:
                                        down_payoff=option_tree_1[j+1,i+1,m]
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j,i+1,m]:
                                        mid_payoff=option_tree_1[j,i+1,m]                                   
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j-1,i+1,m]:
                                        up_payoff=option_tree_1[j-1,i+1,m]
                                # store cur i payoff in option_tree_1
                                option_tree_1[j,i,k]=np.exp(-self.r*dt)*(p_u*up_payoff+p_m*mid_payoff+p_d*down_payoff)                                
        return np.round(option_tree_1,2)
    #--->


    #--->
    
    def floating_US_option_tree(self, N):
        underlying_tree = self.floating_underlying_price_tree(N)
        
        option_tree = np.zeros([2**N, N+1])
        
        dt, u = self.T/N, np.exp(self.sigma*np.sqrt(self.T/N))
        d = 1/u; p = (np.exp((self.r-self.q)*dt)-d)/(u-d)
        
        option_tree[:,N] = np.maximum(np.zeros(2**N), (1-2*self.I)*(underlying_tree[:,N,1] - underlying_tree[:,N,0]))
        for i in np.arange(N-1,-1,-1):
            for j in np.arange(0,2**i):
                option_tree[j,i]=np.exp(-self.r*dt)*(p*option_tree[2*j,i+1]+(1-p)*option_tree[2*j+1,i+1])
            
            option_tree[0:2**i,i]= np.maximum(option_tree[0:2**i, i], (1-2*self.I)*(underlying_tree[0:2**i,i,1] - underlying_tree[0:2**i,i,0]))
        
        return np.round(option_tree,2)
    
    # <--- TRIAL
    def floating_US_option_tree_0(self, N):
        list_size=int(np.floor(N)/2+1)
        underlying_tree_0 = self.floating_underlying_price_tree_0(N)
        option_tree_0 = np.zeros([N+1, N+1,list_size+1])
        
        dt, u = self.T/N, np.exp(self.sigma*np.sqrt(self.T/N))
        d = 1/u; p = (np.exp((self.r-self.q)*dt)-d)/(u-d)

        # put option, max list
        if self.I==0:
            for i in np.arange(N-1,-1,-1):
                for j in np.arange(0,i+1):
                    # N-1 tree nodes
                    if i==N-1:        
                        for k in range(1,list_size+1):
                            if underlying_tree_0[j,i,k]!=0:  
                                # compare i list with i+1 list, match found then calc. payoff
                                for m in range(1,list_size+1):
                                    if underlying_tree_0[j,i,k]==underlying_tree_0[j,i+1,m]:
                                        up_payoff=underlying_tree_0[j,i+1,m]-underlying_tree_0[j,i+1,0]
                                    if round(underlying_tree_0[j,i,k]*u,2)==underlying_tree_0[j,i+1,m] and underlying_tree_0[j,i,k]==underlying_tree_0[j,i,0]:
                                        up_payoff=round(underlying_tree_0[j,i,0]*u,2)-underlying_tree_0[j,i+1,0]
                                    if underlying_tree_0[j,i,k]==underlying_tree_0[j+1,i+1,m]:
                                        down_payoff=underlying_tree_0[j,i,k]-underlying_tree_0[j+1,i+1,0]
                                # store cur i payoff in option_tree_0, check larger payoff if early exercise
                                option_tree_0[j,i,k]=np.exp(-self.r*dt)*((p*up_payoff)+(1-p)*down_payoff)
                                option_tree_0[j,i,k]=max(underlying_tree_0[j,i,k]-underlying_tree_0[j,i,0],option_tree_0[j,i,k])
                    # tree nodes before N-1
                    else:
                        for k in range(1,list_size+1):
                            if underlying_tree_0[j,i,k]!=0:
                                # compare i list with i+1 list, match found then extract i+1 payoff
                                for m in range(1,list_size+1):
                                    if underlying_tree_0[j,i,k]==underlying_tree_0[j,i+1,m]:
                                        up_payoff=option_tree_0[j,i+1,m]
                                    if round(underlying_tree_0[j,i,k]*u,2)==underlying_tree_0[j,i+1,m] and underlying_tree_0[j,i,k]==underlying_tree_0[j,i,0]:
                                        up_payoff=option_tree_0[j,i+1,m]
                                    if underlying_tree_0[j,i,k]==underlying_tree_0[j+1,i+1,m]:
                                        down_payoff=option_tree_0[j+1,i+1,m]
                                # store cur i payoff in option_tree_0, check larger payoff if early exercise
                                option_tree_0[j,i,k]=np.exp(-self.r*dt)*((p*up_payoff)+(1-p)*down_payoff)
                                option_tree_0[j,i,k]=max(underlying_tree_0[j,i,k]-underlying_tree_0[j,i,0],option_tree_0[j,i,k])
        # call option, min list
        else:
            for i in np.arange(N-1,-1,-1):
                for j in np.arange(0,i+1):
                    # N-1 tree nodes
                    if i==N-1:        
                        for k in range(1,list_size+1):
                            if underlying_tree_0[j,i,k]!=0:  
                                # compare i list with i+1 list, match found then calc. payoff
                                for m in range(1,list_size+1):
                                    if underlying_tree_0[j,i,k]==underlying_tree_0[j+1,i+1,m]:
                                        down_payoff=underlying_tree_0[j+1,i+1,0]-underlying_tree_0[j+1,i+1,m]
                                    if round(underlying_tree_0[j,i,k]*d,2)==underlying_tree_0[j+1,i+1,m] and underlying_tree_0[j,i,k]==underlying_tree_0[j,i,0]:
                                        down_payoff=underlying_tree_0[j+1,i+1,0]-round(underlying_tree_0[j,i,0]*d,2)
                                    if underlying_tree_0[j,i,k]==underlying_tree_0[j,i+1,m]:
                                        up_payoff=underlying_tree_0[j,i+1,0]-underlying_tree_0[j,i,k]
                                # store cur i payoff in option_tree_0, check larger payoff if early exercise
                                option_tree_0[j,i,k]=np.exp(-self.r*dt)*((p*up_payoff)+(1-p)*down_payoff)
                                option_tree_0[j,i,k]=max(underlying_tree_0[j,i,0]-underlying_tree_0[j,i,k],option_tree_0[j,i,k])
                    # tree nodes before N-1
                    else:
                        for k in range(1,list_size+1):
                            if underlying_tree_0[j,i,k]!=0:
                                # compare i list with i+1 list, match found then extract i+1 payoff
                                for m in range(1,list_size+1):
                                    if underlying_tree_0[j,i,k]==underlying_tree_0[j+1,i+1,m]:
                                        down_payoff=option_tree_0[j+1,i+1,m]
                                    if round(underlying_tree_0[j,i,k]*d,2)==underlying_tree_0[j+1,i+1,m] and underlying_tree_0[j,i,k]==underlying_tree_0[j,i,0]:
                                        down_payoff=option_tree_0[j+1,i+1,m]
                                    if underlying_tree_0[j,i,k]==underlying_tree_0[j,i+1,m]:
                                        up_payoff=option_tree_0[j,i+1,m]
                                # store cur i payoff in option_tree_0, check larger payoff if early exercise
                                option_tree_0[j,i,k]=np.exp(-self.r*dt)*((p*up_payoff)+(1-p)*down_payoff)
                                option_tree_0[j,i,k]=max(underlying_tree_0[j,i,0]-underlying_tree_0[j,i,k],option_tree_0[j,i,k])

        return np.round(option_tree_0,2)
    #--->

    # <--- TRIAL
    def floating_US_option_tree_1(self, N):
        list_size=int(np.floor(N)/2+1)
        underlying_tree_1 = self.floating_underlying_price_tree_1(N)
        option_tree_1 = np.zeros([2*N+1, N+1,list_size+1])
        
        #dt, u = self.T/N, np.exp(self.sigma*np.sqrt(self.T/N))
        #d = 1/u; p = (np.exp((self.r-self.q)*dt)-d)/(u-d)
        dt, u = self.T/N, np.exp(self.sigma*np.sqrt(3*self.T/N))
        d = 1/u; p = (np.exp((self.r-self.q)*dt)-d)/(u-d)
        p_d = - (np.sqrt(dt/(12*self.sigma*self.sigma)))*(self.r-self.q-0.5*self.sigma*self.sigma) + 1/6
        p_m = 2/3; p_u = (np.sqrt(dt/(12*self.sigma*self.sigma)))*(self.r-self.q-0.5*self.sigma*self.sigma) + 1/6

        # put option, max list
        if self.I==0:
            for i in np.arange(N-1,-1,-1):
                for j in np.arange(N-i,N+i+1):
                    # N-1 tree nodes
                    if i==N-1:        
                        for k in range(1,list_size+1):
                            if underlying_tree_1[j,i,k]!=0:  
                                # compare i list with i+1 list, match found then calc. payoff
                                for m in range(1,list_size+1):
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j-1,i+1,m]:
                                        up_payoff=underlying_tree_1[j-1,i+1,m]-underlying_tree_1[j-1,i+1,0]
                                    if round(underlying_tree_1[j,i,k]*u,2)==underlying_tree_1[j-1,i+1,m] and underlying_tree_1[j,i,k]==underlying_tree_1[j,i,0]:
                                        up_payoff=round(underlying_tree_1[j,i,0]*u,2)-underlying_tree_1[j-1,i+1,0]
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j,i+1,m]:
                                        mid_payoff=underlying_tree_1[j,i+1,m]-underlying_tree_1[j,i+1,0]
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j+1,i+1,m]:
                                        down_payoff=underlying_tree_1[j,i,k]-underlying_tree_1[j+1,i+1,0]
                                # store cur i payoff in option_tree_1, check larger payoff if early exercise
                                option_tree_1[j,i,k]=np.exp(-self.r*dt)*(p_u*up_payoff+p_m*mid_payoff+p_d*down_payoff)
                                option_tree_1[j,i,k]=max(underlying_tree_1[j,i,k]-underlying_tree_1[j,i,0],option_tree_1[j,i,k])
                    # tree nodes before N-1
                    else:
                        for k in range(1,list_size+1):
                            if underlying_tree_1[j,i,k]!=0:
                                # compare i list with i+1 list, match found then extract i+1 payoff
                                for m in range(1,list_size+1):
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j-1,i+1,m]:
                                        up_payoff=option_tree_1[j-1,i+1,m]
                                    if round(underlying_tree_1[j,i,k]*u,2)==underlying_tree_1[j-1,i+1,m] and underlying_tree_1[j,i,k]==underlying_tree_1[j,i,0]:
                                        up_payoff=option_tree_1[j-1,i+1,m]
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j,i+1,m]:
                                        mid_payoff=option_tree_1[j,i+1,m]
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j+1,i+1,m]:
                                        down_payoff=option_tree_1[j+1,i+1,m]
                                # store cur i payoff in option_tree_1, check larger payoff if early exercise
                                option_tree_1[j,i,k]=np.exp(-self.r*dt)*(p_u*up_payoff+p_m*mid_payoff+p_d*down_payoff)
                                option_tree_1[j,i,k]=max(underlying_tree_1[j,i,k]-underlying_tree_1[j,i,0],option_tree_1[j,i,k])
        # call option, min list
        else:
            for i in np.arange(N-1,-1,-1):
                for j in np.arange(N-i,N+i+1):
                    # N-1 tree nodes
                    if i==N-1:        
                        for k in range(1,list_size+1):
                            if underlying_tree_1[j,i,k]!=0:  
                                # compare i list with i+1 list, match found then calc. payoff
                                for m in range(1,list_size+1):
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j+1,i+1,m]:
                                        down_payoff=underlying_tree_1[j+1,i+1,0]-underlying_tree_1[j+1,i+1,m]
                                    if round(underlying_tree_1[j,i,k]*d,2)==underlying_tree_1[j+1,i+1,m] and underlying_tree_1[j,i,k]==underlying_tree_1[j,i,0]:
                                        down_payoff=underlying_tree_1[j+1,i+1,0]-round(underlying_tree_1[j,i,0]*d,2)
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j,i+1,m]:
                                        mid_payoff=underlying_tree_1[j,i+1,0]-underlying_tree_1[j,i+1,m]
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j-1,i+1,m]:
                                        up_payoff=underlying_tree_1[j-1,i+1,0]-underlying_tree_1[j,i,k]
                                # store cur i payoff in option_tree_1, check larger payoff if early exercise
                                option_tree_1[j,i,k]=np.exp(-self.r*dt)*(p_u*up_payoff+p_m*mid_payoff+p_d*down_payoff)
                                option_tree_1[j,i,k]=max(underlying_tree_1[j,i,0]-underlying_tree_1[j,i,k],option_tree_1[j,i,k])
                    # tree nodes before N-1
                    else:
                        for k in range(1,list_size+1):
                            if underlying_tree_1[j,i,k]!=0:
                                # compare i list with i+1 list, match found then extract i+1 payoff
                                for m in range(1,list_size+1):
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j+1,i+1,m]:
                                        down_payoff=option_tree_1[j+1,i+1,m]
                                    if round(underlying_tree_1[j,i,k]*d,2)==underlying_tree_1[j+1,i+1,m] and underlying_tree_1[j,i,k]==underlying_tree_1[j,i,0]:
                                        down_payoff=option_tree_1[j+1,i+1,m]
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j,i+1,m]:
                                        mid_payoff=option_tree_1[j,i+1,m]                                   
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j-1,i+1,m]:
                                        up_payoff=option_tree_1[j-1,i+1,m]
                                # store cur i payoff in option_tree_1, check larger payoff if early exercise
                                option_tree_1[j,i,k]=np.exp(-self.r*dt)*(p_u*up_payoff+p_m*mid_payoff+p_d*down_payoff)   
                                option_tree_1[j,i,k]=max(underlying_tree_1[j,i,0]-underlying_tree_1[j,i,k],option_tree_1[j,i,k])

        return np.round(option_tree_1,2)
    #--->

    
    ## -------------------------------------- BT floating ----------------------------------------- ##

    ## --------------------------------------- BT fixed ------------------------------------------- ##
    def fixed_underlying_price_tree(self, N):
        '''input: the option and the number of periods'''
        '''output: the binomial tree of the underlying price (N+1 * 2**(N) * 2 array)'''
        
        ## parameter initializing
        dt, u = self.T/N, np.exp(self.sigma*np.sqrt(self.T/N))
        d = 1/u; p = (np.exp((self.r-self.q)*dt)-d)/(u-d)
        
        underlying_tree = np.zeros([2**N,N+1,2])
        
        underlying_tree[0,0,0] = self.S0
        underlying_tree[0,0,1] = self.S0
        
        if self.I == 0:
            ## put option ##
            for i in range(1,N+1):
                for j in range(2**i):
                    if j % 2 == 0:
                        underlying_tree[j,i,0] = round(underlying_tree[int(j/2),i-1,0]*u,2)
                        underlying_tree[j,i,1] = min(underlying_tree[j,i,0], underlying_tree[int(j/2),i-1,1])
                    else:
                        underlying_tree[j,i,0] = round(underlying_tree[int((j-1)/2),i-1,0]*d,2)
                        underlying_tree[j,i,1] = min(underlying_tree[j,i,0], underlying_tree[int(j/2),i-1,1])
        
        else:
            for i in range(1,N+1):
                for j in range(2**i):
                    if j % 2 == 0:
                        underlying_tree[j,i,0] = round(underlying_tree[int(j/2),i-1,0]*u,2)
                        underlying_tree[j,i,1] = max(underlying_tree[j,i,0], underlying_tree[int(j/2),i-1,1])
                    else:
                        underlying_tree[j,i,0] = round(underlying_tree[int((j-1)/2),i-1,0]*d,2)
                        underlying_tree[j,i,1] = max(underlying_tree[j,i,0], underlying_tree[int(j/2),i-1,1])
        
        return underlying_tree

    # <--- TRIAL    
    def fixed_underlying_price_tree_0(self, N):
                
        ## parameter initializing
        dt, u = self.T/N, np.exp(self.sigma*np.sqrt(self.T/N))
        d = 1/u; p = (np.exp((self.r-self.q)*dt)-d)/(u-d)
        print('p ',p,'u ',u,'dt ',dt)
        
        # compute list size
        list_size=int(np.floor(N)/2+1)
        temp_list=np.zeros(list_size)
        print('list size',list_size)
        
        # underlying_tree_0[j,i,0] index 0 store underlying price
        # underlying tree_0[j,i,1:] index 1 onwards store max or min
        underlying_tree_0= np.zeros([N+1,N+1,list_size+1])
        underlying_tree_0[0,0,0] = self.S0
        underlying_tree_0[0,0,1]= self.S0    # first max or min list item
        underlying_tree_0[0,0,2:]=0        
        
        # check if element exist in array
        def checkif_exist(array_,element):
            exist=0
            for n in range(len(array_)):
                if array_[n]==element:
                    exist=1
            return exist
        
        # check the next available index of empty slots in array
        def fnext_index(array_):
            index_=-1
            for n in range(len(array_)):
                if array_[n]==0:
                    index_=n
                    break
            return index_
                    
        # put option, min list
        if self.I == 0:
            for i in range(1,N+1):
                for j in range(i+1):
                    # generate underlying price for tree
                    if j==0:
                        underlying_tree_0[j,i,0] = round(underlying_tree_0[int(j),i-1,0]*u,2)
                    else:
                        underlying_tree_0[j,i,0] = round(underlying_tree_0[int(j-1),i-1,0]*d,2)           
                    # if not lowest branch
                    if j!=i:
                        cnt=fnext_index(underlying_tree_0[j,i,1:])+1
                        # add min list items from prev lower left branch if <= cur price
                        for k in range(1,list_size+1):
                            if underlying_tree_0[j,i-1,k]!=0 and underlying_tree_0[j,i-1,k]<=underlying_tree_0[j,i,0]:
                                if checkif_exist(underlying_tree_0[j,i,1:],underlying_tree_0[j,i-1,k])==0:
                                    underlying_tree_0[j,i,cnt]=underlying_tree_0[j,i-1,k]
                                    cnt+=1
                    # if not highest branch
                    if j>=1:
                        cnt=fnext_index(underlying_tree_0[j,i,1:])+1
                        cnt_old=cnt
                        # add min list items from prev upper left branch if <= cur price
                        for k in range(1,list_size+1):
                            if underlying_tree_0[j-1,i-1,k]!=0 and underlying_tree_0[j-1,i-1,k]<=underlying_tree_0[j,i,0]:
                                if checkif_exist(underlying_tree_0[j,i,1:],underlying_tree_0[j-1,i-1,k])==0:   
                                     underlying_tree_0[j,i,cnt]=underlying_tree_0[j-1,i-1,k]
                                     cnt+=1
                        # add cur price to list if none was added from prev upper left list (i.e. lowest price)
                        if cnt==cnt_old and cnt==1:
                            underlying_tree_0[j,i,cnt]=underlying_tree_0[j,i,0]
                            cnt+=1            
        # call option, max list
        else:              
            for i in range(1,N+1):
                for j in range(i+1):
                    # generate underlying price for tree
                    if j==0:
                        underlying_tree_0[j,i,0] = round(underlying_tree_0[int(j),i-1,0]*u,2)
                    else:
                        underlying_tree_0[j,i,0] = round(underlying_tree_0[int(j-1),i-1,0]*d,2)                           
                    # if not lowest branch
                    if j!=i:
                        cnt=fnext_index(underlying_tree_0[j,i,1:])+1
                        cnt_old=cnt
                        # add max list items from prev lower left branch if >= cur price
                        for k in range(1,list_size+1):
                            if underlying_tree_0[j,i-1,k]!=0 and underlying_tree_0[j,i-1,k]>=underlying_tree_0[j,i,0]:
                                if checkif_exist(underlying_tree_0[j,i,1:],underlying_tree_0[j,i-1,k])==0:
                                    underlying_tree_0[j,i,cnt]=underlying_tree_0[j,i-1,k]
                                    cnt+=1
                        # add cur price to list if none was added from prev lower left list (i.e. highest price)
                        if cnt==cnt_old:
                            underlying_tree_0[j,i,cnt]=underlying_tree_0[j,i,0]
                            cnt+=1
                    # if not highest branch
                    if j>=1:
                        cnt=fnext_index(underlying_tree_0[j,i,1:])+1
                        # add max list items from prev upper left branch if >= cur price
                        for k in range(1,list_size+1):
                            if underlying_tree_0[j-1,i-1,k]!=0 and underlying_tree_0[j-1,i-1,k]>=underlying_tree_0[j,i,0]:
                                if checkif_exist(underlying_tree_0[j,i,1:],underlying_tree_0[j-1,i-1,k])==0:   
                                     underlying_tree_0[j,i,cnt]=underlying_tree_0[j-1,i-1,k]
                                     cnt+=1

        # sort the list at each node from high to low
        for i in range(1,N+1):
                for j in range(i+1):
                    temp_list=sorted(underlying_tree_0[j,i,1:],reverse=True)
                    underlying_tree_0[j,i,1:]=temp_list
                            
        return underlying_tree_0
    #--->    

    # <--- TRIAL    
    def fixed_underlying_price_tree_1(self, N):
                     
        ## parameter initializing
        dt, u = self.T/N, np.exp(self.sigma*np.sqrt(3*self.T/N))
        d = 1/u; p = (np.exp((self.r-self.q)*dt)-d)/(u-d)
        p_d = - (np.sqrt(dt/(12*self.sigma*self.sigma)))*(self.r-self.q-0.5*self.sigma*self.sigma) + 1/6
        p_m = 2/3; p_u = (np.sqrt(dt/(12*self.sigma*self.sigma)))*(self.r-self.q-0.5*self.sigma*self.sigma) + 1/6
        
        print('p ',p,'u ',u,'dt ',dt)
        print('p_u',p_u,'p_m',p_m,'p_d',p_d)
        
        # compute list size
        list_size=int(np.floor(N)/2+1)
        temp_list=np.zeros(list_size)
        print('list size',list_size)
        
        # underlying_tree_0[j,i,0] index 0 store underlying price
        # underlying tree_0[j,i,1:] index 1 onwards store max or min
        underlying_tree_1= np.zeros([2*N+1,N+1,list_size+1])
        underlying_tree_1[N,:,0] = self.S0
        underlying_tree_1[N,0,1]= self.S0    # first max or min list item
        underlying_tree_1[0,0,2:]=0        
        
        # check if element exist in array
        def checkif_exist(array_,element):
            exist=0
            for n in range(len(array_)):
                if array_[n]==element:
                    exist=1
            return exist
        
        # check the next available index of empty slots in array
        def fnext_index(array_):
            index_=-1
            for n in range(len(array_)):
                if array_[n]==0:
                    index_=n
                    break
            return index_
        
                # generate underlying price for tree first
        for i in range(1,N+1):
            for j in range(1,i+1):
                underlying_tree_1[N-j,i,0] = round(underlying_tree_1[N+1-j, i-1,0]*u,2)
                underlying_tree_1[N+j,i,0] = round(underlying_tree_1[N-1+j, i-1,0]*d,2)    
                    
        # put option, min list
        if self.I == 0:
            for i in range(1,N+1):
                for j in range(N-i,N+i+1):
                    cnt=fnext_index(underlying_tree_1[j,i,1:])+1
                    cnt_old=cnt
                    # if not lowest branch and 2nd lowest branch                   
                    if j<N+i-1:
                        cnt=fnext_index(underlying_tree_1[j,i,1:])+1
                        # add min list items from prev lower left branch if <= cur price
                        for k in range(1,list_size+1):
                            if underlying_tree_1[j+1,i-1,k]!=0 and underlying_tree_1[j+1,i-1,k]<=underlying_tree_1[j,i,0]:
                                if checkif_exist(underlying_tree_1[j,i,1:],underlying_tree_1[j+1,i-1,k])==0:
                                    underlying_tree_1[j,i,cnt]=underlying_tree_1[j+1,i-1,k]
                                    cnt+=1
                    # if not the lowest branch or highest branch
                    if j!=N+i or j!=N-i:
                        # add min list items from prev middle left branch if <= cur price
                        for k in range(1,list_size+1):
                            if underlying_tree_1[j,i-1,k]!=0 and underlying_tree_1[j,i-1,k]<=underlying_tree_1[j,i,0]:
                                if checkif_exist(underlying_tree_1[j,i,1:],underlying_tree_1[j,i-1,k])==0:
                                    underlying_tree_1[j,i,cnt]=underlying_tree_1[j,i-1,k]
                                    cnt+=1                                                    
                    # if not highest branch and 2nd highest branch
                    if j>N-i+1:
                        # add min list items from prev upper left branch if <= cur price
                        for k in range(1,list_size+1):
                            if underlying_tree_1[j-1,i-1,k]!=0 and underlying_tree_1[j-1,i-1,k]<=underlying_tree_1[j,i,0]:
                                if checkif_exist(underlying_tree_1[j,i,1:],underlying_tree_1[j-1,i-1,k])==0:   
                                     underlying_tree_1[j,i,cnt]=underlying_tree_1[j-1,i-1,k]
                                     cnt+=1
                    # add cur price to list if none was added from prev upper left list (i.e. lowest price)
                    if cnt==cnt_old and cnt==1:
                        underlying_tree_1[j,i,cnt]=underlying_tree_1[j,i,0]
                        cnt+=1                      
        # call option, max list
        else:              
            for i in range(1,N+1):
                for j in range(N-i,N+i+1):
                    cnt=fnext_index(underlying_tree_1[j,i,1:])+1
                    cnt_old=cnt
                    # if not lowest branch and 2nd lowest branch                   
                    if j<N+i-1:
                        cnt=fnext_index(underlying_tree_1[j,i,1:])+1
                        # add max list items from prev lower left branch if >= cur price
                        for k in range(1,list_size+1):
                            if underlying_tree_1[j+1,i-1,k]!=0 and underlying_tree_1[j+1,i-1,k]>=underlying_tree_1[j,i,0]:
                                if checkif_exist(underlying_tree_1[j,i,1:],underlying_tree_1[j+1,i-1,k])==0:
                                    underlying_tree_1[j,i,cnt]=underlying_tree_1[j+1,i-1,k]
                                    cnt+=1                  
                    # if not the lowest branch or highest branch
                    if j!=N+i or j!=N-i:
                        # add max list items from prev middle left branch if >= cur price
                        for k in range(1,list_size+1):
                            if underlying_tree_1[j,i-1,k]!=0 and underlying_tree_1[j,i-1,k]>=underlying_tree_1[j,i,0]:
                                if checkif_exist(underlying_tree_1[j,i,1:],underlying_tree_1[j,i-1,k])==0:
                                    underlying_tree_1[j,i,cnt]=underlying_tree_1[j,i-1,k]
                                    cnt+=1           
                    # if not highest branch and 2nd highest branch
                    if j>N-i+1:
                        # add max list items from prev upper left branch if >= cur price
                        for k in range(1,list_size+1):
                            if underlying_tree_1[j-1,i-1,k]!=0 and underlying_tree_1[j-1,i-1,k]>=underlying_tree_1[j,i,0]:
                                if checkif_exist(underlying_tree_1[j,i,1:],underlying_tree_1[j-1,i-1,k])==0:   
                                     underlying_tree_1[j,i,cnt]=underlying_tree_1[j-1,i-1,k]
                                     cnt+=1                                    
                    # add cur price to list if none was added from prev nodes list (i.e. highest price)
                    if cnt==cnt_old:
                        underlying_tree_1[j,i,cnt]=underlying_tree_1[j,i,0]
                        cnt+=1                

        # sort the list at each node from high to low
        for i in range(1,N+1):
                for j in range(N-i,N+i+1):
                    temp_list=sorted(underlying_tree_1[j,i,1:],reverse=True)
                    underlying_tree_1[j,i,1:]=temp_list
                            
        return underlying_tree_1
    #--->    
    
    def fixed_EU_option_tree(self,N):
        underlying_tree = self.fixed_underlying_price_tree(N)
        option_tree = np.zeros([2**N, N+1])
        
        dt, u = self.T/N, np.exp(self.sigma*np.sqrt(self.T/N))
        d = 1/u; p = (np.exp((self.r-self.q)*dt)-d)/(u-d)
        
        option_tree[:,N] = np.maximum(np.zeros(2**N),(1-2*self.I)* (self.K - underlying_tree[:,N,1]))
        for i in np.arange(N-1,-1,-1):
            for j in np.arange(0,2**i):
                option_tree[j,i]=np.exp(-self.r*dt)*(p*option_tree[2*j,i+1]+(1-p)*option_tree[2*j+1,i+1])
        
        return np.round(option_tree,2)
    
    # <--- TRIAL
    def fixed_EU_option_tree_0(self, N):
        list_size=int(np.floor(N)/2+1)
        underlying_tree_0 = self.fixed_underlying_price_tree_0(N)
        option_tree_0 = np.zeros([N+1, N+1,list_size+1])
        
        dt, u = self.T/N, np.exp(self.sigma*np.sqrt(self.T/N))
        d = 1/u; p = (np.exp((self.r-self.q)*dt)-d)/(u-d)
        
        # put option, min list            
        if self.I==0:
            for i in np.arange(N-1,-1,-1):
                for j in np.arange(0,i+1):
                    # N-1 tree nodes
                    if i==N-1:        
                        for k in range(1,list_size+1):
                            if underlying_tree_0[j,i,k]!=0:  
                                # compare i list with i+1 list, match found then calc. payoff
                                for m in range(1,list_size+1):
                                    if underlying_tree_0[j,i,k]==underlying_tree_0[j+1,i+1,m]:
                                        down_payoff=max(0,self.K-underlying_tree_0[j+1,i+1,m])
                                    if round(underlying_tree_0[j,i,k]*d,2)==underlying_tree_0[j+1,i+1,m] and underlying_tree_0[j,i,k]==underlying_tree_0[j,i,0]:
                                        down_payoff=max(0,self.K-round(underlying_tree_0[j,i,0]*d,2))
                                    if underlying_tree_0[j,i,k]==underlying_tree_0[j,i+1,m]:
                                        up_payoff=max(0,self.K-underlying_tree_0[j,i,k])
                                # store cur i payoff in option_tree_0
                                option_tree_0[j,i,k]=np.exp(-self.r*dt)*((p*up_payoff)+(1-p)*down_payoff)
                    # tree nodes before N-1
                    else:
                        for k in range(1,list_size+1):
                            if underlying_tree_0[j,i,k]!=0:
                                # compare i list with i+1 list, match found then extract i+1 payoff
                                for m in range(1,list_size+1):
                                    if underlying_tree_0[j,i,k]==underlying_tree_0[j+1,i+1,m]:
                                        down_payoff=option_tree_0[j+1,i+1,m]
                                    if round(underlying_tree_0[j,i,k]*d,2)==underlying_tree_0[j+1,i+1,m] and underlying_tree_0[j,i,k]==underlying_tree_0[j,i,0]:
                                        down_payoff=option_tree_0[j+1,i+1,m]
                                    if underlying_tree_0[j,i,k]==underlying_tree_0[j,i+1,m]:
                                        up_payoff=option_tree_0[j,i+1,m]
                                # store cur i payoff in option_tree_0
                                option_tree_0[j,i,k]=np.exp(-self.r*dt)*((p*up_payoff)+(1-p)*down_payoff)
        # call option, max list
        else:
            for i in np.arange(N-1,-1,-1):
                for j in np.arange(0,i+1):
                    # N-1 tree nodes
                    if i==N-1:        
                        for k in range(1,list_size+1):
                            if underlying_tree_0[j,i,k]!=0:  
                                # compare i list with i+1 list, match found then calc. payoff
                                for m in range(1,list_size+1):
                                    if underlying_tree_0[j,i,k]==underlying_tree_0[j,i+1,m]:
                                        up_payoff=max(0,underlying_tree_0[j,i+1,m]-self.K)
                                    if round(underlying_tree_0[j,i,k]*u,2)==underlying_tree_0[j,i+1,m] and underlying_tree_0[j,i,k]==underlying_tree_0[j,i,0]:
                                        up_payoff=max(0,round(underlying_tree_0[j,i,0]*u,2)-self.K)
                                    if underlying_tree_0[j,i,k]==underlying_tree_0[j+1,i+1,m]:
                                        down_payoff=max(0,underlying_tree_0[j,i,k]-self.K)
                                # store cur i payoff in option_tree_0
                                option_tree_0[j,i,k]=np.exp(-self.r*dt)*((p*up_payoff)+(1-p)*down_payoff)
                    # tree nodes before N-1
                    else:
                        for k in range(1,list_size+1):
                            if underlying_tree_0[j,i,k]!=0:
                                # compare i list with i+1 list, match found then extract i+1 payoff
                                for m in range(1,list_size+1):
                                    if underlying_tree_0[j,i,k]==underlying_tree_0[j,i+1,m]:
                                        up_payoff=option_tree_0[j,i+1,m]
                                    if round(underlying_tree_0[j,i,k]*u,2)==underlying_tree_0[j,i+1,m] and underlying_tree_0[j,i,k]==underlying_tree_0[j,i,0]:
                                        up_payoff=option_tree_0[j,i+1,m]
                                    if underlying_tree_0[j,i,k]==underlying_tree_0[j+1,i+1,m]:
                                        down_payoff=option_tree_0[j+1,i+1,m]
                                # store cur i payoff in option_tree_0
                                option_tree_0[j,i,k]=np.exp(-self.r*dt)*((p*up_payoff)+(1-p)*down_payoff)
                                
        return np.round(option_tree_0,2)
    #--->

    # <--- TRIAL
    def fixed_EU_option_tree_1(self, N):
        list_size=int(np.floor(N)/2+1)
        underlying_tree_1 = self.fixed_underlying_price_tree_1(N)
        option_tree_1 = np.zeros([2*N+1, N+1,list_size*2])

        #dt, u = self.T/N, np.exp(self.sigma*np.sqrt(self.T/N))
        #d = 1/u; p = (np.exp((self.r-self.q)*dt)-d)/(u-d)
        dt, u = self.T/N, np.exp(self.sigma*np.sqrt(3*self.T/N))
        d = 1/u; p = (np.exp((self.r-self.q)*dt)-d)/(u-d)
        p_d = - (np.sqrt(dt/(12*self.sigma*self.sigma)))*(self.r-self.q-0.5*self.sigma*self.sigma) + 1/6
        p_m = 2/3; p_u = (np.sqrt(dt/(12*self.sigma*self.sigma)))*(self.r-self.q-0.5*self.sigma*self.sigma) + 1/6
                
        # put option, min list            
        if self.I==0:
            for i in np.arange(N-1,-1,-1):
                for j in np.arange(N-i,N+i+1):
                    # N-1 tree nodes
                    if i==N-1:        
                        for k in range(1,list_size+1):
                            if underlying_tree_1[j,i,k]!=0:  
                                # compare i list with i+1 list, match found then calc. payoff
                                for m in range(1,list_size+1):
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j+1,i+1,m]:
                                        down_payoff=max(0,self.K-underlying_tree_1[j+1,i+1,m])
                                    if round(underlying_tree_1[j,i,k]*d,2)==underlying_tree_1[j+1,i+1,m] and underlying_tree_1[j,i,k]==underlying_tree_1[j,i,0]:
                                        down_payoff=max(0,self.K-round(underlying_tree_1[j,i,0]*d,2))
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j,i+1,m]:
                                        mid_payoff=max(0,self.K-underlying_tree_1[j,i+1,m])
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j-1,i+1,m]:
                                        up_payoff=max(0,self.K-underlying_tree_1[j,i,k])
                                # store cur i payoff in option_tree_1
                                option_tree_1[j,i,k]=np.exp(-self.r*dt)*(p_u*up_payoff+p_m*mid_payoff+p_d*down_payoff)
                    # tree nodes before N-1
                    else:
                        for k in range(1,list_size+1):
                            if underlying_tree_1[j,i,k]!=0:
                                # compare i list with i+1 list, match found then extract i+1 payoff
                                for m in range(1,list_size+1):
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j+1,i+1,m]:
                                        down_payoff=option_tree_1[j+1,i+1,m]
                                    if round(underlying_tree_1[j,i,k]*d,2)==underlying_tree_1[j+1,i+1,m] and underlying_tree_1[j,i,k]==underlying_tree_1[j,i,0]:
                                        down_payoff=option_tree_1[j+1,i+1,m]
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j,i+1,m]:
                                        mid_payoff=option_tree_1[j,i+1,m]                                   
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j-1,i+1,m]:
                                        up_payoff=option_tree_1[j-1,i+1,m]
                                # store cur i payoff in option_tree_1
                                option_tree_1[j,i,k]=np.exp(-self.r*dt)*(p_u*up_payoff+p_m*mid_payoff+p_d*down_payoff)      

        # call option, max list
        else:
            for i in np.arange(N-1,-1,-1):
                for j in np.arange(N-i,N+i+1):
                    # N-1 tree nodes
                    if i==N-1:        
                        for k in range(1,list_size+1):
                            if underlying_tree_1[j,i,k]!=0:  
                                # compare i list with i+1 list, match found then calc. payoff
                                for m in range(1,list_size+1):
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j-1,i+1,m]:
                                        up_payoff=max(0,underlying_tree_1[j-1,i+1,m]-self.K)
                                    if round(underlying_tree_1[j,i,k]*u,2)==underlying_tree_1[j-1,i+1,m] and underlying_tree_1[j,i,k]==underlying_tree_1[j,i,0]:
                                        up_payoff=max(0,round(underlying_tree_1[j,i,0]*u,2)-self.K)
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j,i+1,m]:
                                        mid_payoff=max(0,underlying_tree_1[j,i+1,m]-self.K)
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j+1,i+1,m]:
                                        down_payoff=max(0,underlying_tree_1[j,i,k]-self.K)
                                # store cur i payoff in option_tree_1
                                option_tree_1[j,i,k]=np.exp(-self.r*dt)*(p_u*up_payoff+p_m*mid_payoff+p_d*down_payoff)
                    # tree nodes before N-1
                    else:
                        for k in range(1,list_size+1):
                            if underlying_tree_1[j,i,k]!=0:
                                # compare i list with i+1 list, match found then extract i+1 payoff
                                for m in range(1,list_size+1):
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j-1,i+1,m]:
                                        up_payoff=option_tree_1[j-1,i+1,m]
                                    if round(underlying_tree_1[j,i,k]*u,2)==underlying_tree_1[j-1,i+1,m] and underlying_tree_1[j,i,k]==underlying_tree_1[j,i,0]:
                                        up_payoff=option_tree_1[j-1,i+1,m]
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j,i+1,m]:
                                        mid_payoff=option_tree_1[j,i+1,m]
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j+1,i+1,m]:
                                        down_payoff=option_tree_1[j+1,i+1,m]
                                # store cur i payoff in option_tree_1
                                option_tree_1[j,i,k]=np.exp(-self.r*dt)*(p_u*up_payoff+p_m*mid_payoff+p_d*down_payoff)

        return np.round(option_tree_1,2)
    #--->

    
    def fixed_US_option_tree(self, N):
        underlying_tree = self.fixed_underlying_price_tree(N)
        
        option_tree = np.zeros([2**N, N+1])
        
        dt, u = self.T/N, np.exp(self.sigma*np.sqrt(self.T/N))
        d = 1/u; p = (np.exp((self.r-self.q)*dt)-d)/(u-d)
        
        option_tree[:,N] = np.maximum(np.zeros(2**N), (1-2*self.I)*(self.K - underlying_tree[:,N,1]))
        for i in np.arange(N-1,-1,-1):
            for j in np.arange(0,2**i):
                option_tree[j,i]=np.exp(-self.r*dt)*(p*option_tree[2*j,i+1]+(1-p)*option_tree[2*j+1,i+1])
            
            option_tree[0:2**i,i]= np.maximum(option_tree[0:2**i, i], (1-2*self.I)*(self.K-underlying_tree[0:2**i,i,0]))
        
        return np.round(option_tree,2)
    
    # <--- TRIAL    
    def fixed_US_option_tree_0(self, N):
        list_size=int(np.floor(N)/2+1)
        underlying_tree_0 = self.fixed_underlying_price_tree_0(N)
        option_tree_0 = np.zeros([N+1, N+1,list_size+1])
        
        dt, u = self.T/N, np.exp(self.sigma*np.sqrt(self.T/N))
        d = 1/u; p = (np.exp((self.r-self.q)*dt)-d)/(u-d)
        
        # put option, min list            
        if self.I==0:
            for i in np.arange(N-1,-1,-1):
                for j in np.arange(0,i+1):
                    # N-1 tree nodes
                    if i==N-1:        
                        for k in range(1,list_size+1):
                            if underlying_tree_0[j,i,k]!=0:  
                                # compare i list with i+1 list, match found then calc. payoff
                                for m in range(1,list_size+1):
                                    if underlying_tree_0[j,i,k]==underlying_tree_0[j+1,i+1,m]:
                                        down_payoff=max(0,self.K-underlying_tree_0[j+1,i+1,m])
                                    if round(underlying_tree_0[j,i,k]*d,2)==underlying_tree_0[j+1,i+1,m] and underlying_tree_0[j,i,k]==underlying_tree_0[j,i,0]:
                                        down_payoff=max(0,self.K-round(underlying_tree_0[j,i,0]*d,2))
                                    if underlying_tree_0[j,i,k]==underlying_tree_0[j,i+1,m]:
                                        up_payoff=max(0,self.K-underlying_tree_0[j,i,k])
                                # store cur i payoff in option_tree_0, check larger payoff if early exercise
                                option_tree_0[j,i,k]=np.exp(-self.r*dt)*((p*up_payoff)+(1-p)*down_payoff)
                                option_tree_0[j,i,k]=max(self.K-underlying_tree_0[j,i,k],option_tree_0[j,i,k])
                    # tree nodes before N-1
                    else:
                        for k in range(1,list_size+1):
                            if underlying_tree_0[j,i,k]!=0:
                                # compare i list with i+1 list, match found then extract i+1 payoff
                                for m in range(1,list_size+1):
                                    if underlying_tree_0[j,i,k]==underlying_tree_0[j+1,i+1,m]:
                                        down_payoff=option_tree_0[j+1,i+1,m]
                                    if round(underlying_tree_0[j,i,k]*d,2)==underlying_tree_0[j+1,i+1,m] and underlying_tree_0[j,i,k]==underlying_tree_0[j,i,0]:
                                        down_payoff=option_tree_0[j+1,i+1,m]
                                    if underlying_tree_0[j,i,k]==underlying_tree_0[j,i+1,m]:
                                        up_payoff=option_tree_0[j,i+1,m]
                                # store cur i payoff in option_tree_0, check larger payoff if early exercise
                                option_tree_0[j,i,k]=np.exp(-self.r*dt)*((p*up_payoff)+(1-p)*down_payoff)
                                option_tree_0[j,i,k]=max(self.K-underlying_tree_0[j,i,k],option_tree_0[j,i,k])
        # call option, max list
        else:
            for i in np.arange(N-1,-1,-1):
                for j in np.arange(0,i+1):
                    # N-1 tree nodes
                    if i==N-1:        
                        for k in range(1,list_size+1):
                            if underlying_tree_0[j,i,k]!=0:  
                                # compare i list with i+1 list, match found then calc. payoff
                                for m in range(1,list_size+1):
                                    if underlying_tree_0[j,i,k]==underlying_tree_0[j,i+1,m]:
                                        up_payoff=max(0,underlying_tree_0[j,i+1,m]-self.K)
                                    if round(underlying_tree_0[j,i,k]*u,2)==underlying_tree_0[j,i+1,m] and underlying_tree_0[j,i,k]==underlying_tree_0[j,i,0]:
                                        up_payoff=max(0,round(underlying_tree_0[j,i,0]*u,2)-self.K)
                                    if underlying_tree_0[j,i,k]==underlying_tree_0[j+1,i+1,m]:
                                        down_payoff=max(0,underlying_tree_0[j,i,k]-self.K)
                                # store cur i payoff in option_tree_0, check larger payoff if early exercise
                                option_tree_0[j,i,k]=np.exp(-self.r*dt)*((p*up_payoff)+(1-p)*down_payoff)
                                option_tree_0[j,i,k]=max(underlying_tree_0[j,i,k]-self.K,option_tree_0[j,i,k])
                    # tree nodes before N-1
                    else:
                        for k in range(1,list_size+1):
                            if underlying_tree_0[j,i,k]!=0:
                                # compare i list with i+1 list, match found then extract i+1 payoff
                                for m in range(1,list_size+1):
                                    if underlying_tree_0[j,i,k]==underlying_tree_0[j,i+1,m]:
                                        up_payoff=option_tree_0[j,i+1,m]
                                    if round(underlying_tree_0[j,i,k]*u,2)==underlying_tree_0[j,i+1,m] and underlying_tree_0[j,i,k]==underlying_tree_0[j,i,0]:
                                        up_payoff=option_tree_0[j,i+1,m]
                                    if underlying_tree_0[j,i,k]==underlying_tree_0[j+1,i+1,m]:
                                        down_payoff=option_tree_0[j+1,i+1,m]
                                # store cur i payoff in option_tree_0, check larger payoff if early exercise
                                option_tree_0[j,i,k]=np.exp(-self.r*dt)*((p*up_payoff)+(1-p)*down_payoff)
                                option_tree_0[j,i,k]=max(underlying_tree_0[j,i,k]-self.K,option_tree_0[j,i,k])                                
        return np.round(option_tree_0,2)
    #--->


    # <--- TRIAL    
    def fixed_US_option_tree_1(self, N):
        list_size=int(np.floor(N)/2+1)
        underlying_tree_1 = self.fixed_underlying_price_tree_1(N)
        option_tree_1 = np.zeros([2*N+1, N+1,list_size*2])
        
        #dt, u = self.T/N, np.exp(self.sigma*np.sqrt(self.T/N))
        #d = 1/u; p = (np.exp((self.r-self.q)*dt)-d)/(u-d)
        dt, u = self.T/N, np.exp(self.sigma*np.sqrt(3*self.T/N))
        d = 1/u; p = (np.exp((self.r-self.q)*dt)-d)/(u-d)
        p_d = - (np.sqrt(dt/(12*self.sigma*self.sigma)))*(self.r-self.q-0.5*self.sigma*self.sigma) + 1/6
        p_m = 2/3; p_u = (np.sqrt(dt/(12*self.sigma*self.sigma)))*(self.r-self.q-0.5*self.sigma*self.sigma) + 1/6
        
        # put option, min list            
        if self.I==0:
            for i in np.arange(N-1,-1,-1):
                for j in np.arange(N-i,N+i+1):
                    # N-1 tree nodes
                    if i==N-1:        
                        for k in range(1,list_size+1):
                            if underlying_tree_1[j,i,k]!=0:  
                                # compare i list with i+1 list, match found then calc. payoff
                                for m in range(1,list_size+1):
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j+1,i+1,m]:
                                        down_payoff=max(0,self.K-underlying_tree_1[j+1,i+1,m])
                                    if round(underlying_tree_1[j,i,k]*d,2)==underlying_tree_1[j+1,i+1,m] and underlying_tree_1[j,i,k]==underlying_tree_1[j,i,0]:
                                        down_payoff=max(0,self.K-round(underlying_tree_1[j,i,0]*d,2))
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j,i+1,m]:
                                        mid_payoff=max(0,self.K-underlying_tree_1[j,i+1,m])
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j-1,i+1,m]:
                                        up_payoff=max(0,self.K-underlying_tree_1[j,i,k])
                                # store cur i payoff in option_tree_1
                                option_tree_1[j,i,k]=np.exp(-self.r*dt)*(p_u*up_payoff+p_m*mid_payoff+p_d*down_payoff)                        
                                option_tree_1[j,i,k]=max(self.K-underlying_tree_1[j,i,k],option_tree_1[j,i,k])
                    # tree nodes before N-1
                    else:
                        for k in range(1,list_size+1):
                            if underlying_tree_1[j,i,k]!=0:
                                # compare i list with i+1 list, match found then extract i+1 payoff
                                for m in range(1,list_size+1):
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j+1,i+1,m]:
                                        down_payoff=option_tree_1[j+1,i+1,m]
                                    if round(underlying_tree_1[j,i,k]*d,2)==underlying_tree_1[j+1,i+1,m] and underlying_tree_1[j,i,k]==underlying_tree_1[j,i,0]:
                                        down_payoff=option_tree_1[j+1,i+1,m]
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j,i+1,m]:
                                        mid_payoff=option_tree_1[j,i+1,m]                                   
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j-1,i+1,m]:
                                        up_payoff=option_tree_1[j-1,i+1,m]
                                # store cur i payoff in option_tree_1
                                option_tree_1[j,i,k]=np.exp(-self.r*dt)*(p_u*up_payoff+p_m*mid_payoff+p_d*down_payoff)
                                option_tree_1[j,i,k]=max(self.K-underlying_tree_1[j,i,k],option_tree_1[j,i,k])

        # call option, max list
        else:
            for i in np.arange(N-1,-1,-1):
                for j in np.arange(N-i,N+i+1):
                    # N-1 tree nodes
                    if i==N-1:        
                        for k in range(1,list_size+1):
                            if underlying_tree_1[j,i,k]!=0:  
                                # compare i list with i+1 list, match found then calc. payoff
                                for m in range(1,list_size+1):
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j-1,i+1,m]:
                                        up_payoff=max(0,underlying_tree_1[j-1,i+1,m]-self.K)
                                    if round(underlying_tree_1[j,i,k]*u,2)==underlying_tree_1[j-1,i+1,m] and underlying_tree_1[j,i,k]==underlying_tree_1[j,i,0]:
                                        up_payoff=max(0,round(underlying_tree_1[j,i,0]*u,2)-self.K)
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j,i+1,m]:
                                        mid_payoff=max(0,underlying_tree_1[j,i+1,m]-self.K)
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j+1,i+1,m]:
                                        down_payoff=max(0,underlying_tree_1[j,i,k]-self.K)
                                # store cur i payoff in option_tree_1
                                option_tree_1[j,i,k]=np.exp(-self.r*dt)*(p_u*up_payoff+p_m*mid_payoff+p_d*down_payoff)
                                option_tree_1[j,i,k]=max(underlying_tree_1[j,i,k]-self.K,option_tree_1[j,i,k])
                    # tree nodes before N-1
                    else:                             
                        for k in range(1,list_size+1):
                            if underlying_tree_1[j,i,k]!=0:
                                # compare i list with i+1 list, match found then extract i+1 payoff
                                for m in range(1,list_size+1):
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j-1,i+1,m]:
                                        up_payoff=option_tree_1[j-1,i+1,m]
                                    if round(underlying_tree_1[j,i,k]*u,2)==underlying_tree_1[j-1,i+1,m] and underlying_tree_1[j,i,k]==underlying_tree_1[j,i,0]:
                                        up_payoff=option_tree_1[j-1,i+1,m]
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j,i+1,m]:
                                        mid_payoff=option_tree_1[j,i+1,m]
                                    if underlying_tree_1[j,i,k]==underlying_tree_1[j+1,i+1,m]:
                                        down_payoff=option_tree_1[j+1,i+1,m]
                                # store cur i payoff in option_tree_1
                                option_tree_1[j,i,k]=np.exp(-self.r*dt)*(p_u*up_payoff+p_m*mid_payoff+p_d*down_payoff)
                                option_tree_1[j,i,k]=max(underlying_tree_1[j,i,k]-self.K,option_tree_1[j,i,k])  

        return np.round(option_tree_1,2)
    #--->

    
    ## --------------------------------------- BT fixed ------------------------------------------- ##
    
    ## -------------------------------------- BS floating ----------------------------------------- ##
    def floating_BS_call_option_tree(self, Smin):
        N = norm.cdf
        
        ## if the lookback option in our case has just been originated, so Smin = S0
        a1 = (np.log(self.S0/Smin) + (self.r - self.q + self.sigma**2/2)*self.T)/(self.sigma*np.sqrt(self.T))
        a2 = a1 - self.sigma*np.sqrt(self.T)
        a3 = (np.log(self.S0/Smin) + (-self.r + self.q + self.sigma**2/2)*self.T)/(self.sigma*np.sqrt(self.T))
        Y1 = -(2*(self.r - self.q- self.sigma**2/2)*np.log(self.S0/Smin))/self.sigma**2
        
        c = self.S0*np.exp(-self.q*self.T)*N(a1)- self.S0*np.exp(-self.q*self.T)*(self.sigma**2/(2*(self.r-self.q)))*N(-a1)-Smin*np.exp(-self.r*self.T)*(N(a2)-(self.sigma**2/(2*(self.r-self.q)))*np.exp(Y1)*N(-a3))
        return c
    
    def floating_BS_put_option_tree(self, Smax):
        N = norm.cdf
        
        ## the lookback option in our case has just been originated, so Smax = S0
        b1 = (np.log(Smax/self.S0) + (-self.r + self.q + self.sigma**2/2)*self.T)/(self.sigma*np.sqrt(self.T))
        b2 = b1 - self.sigma*np.sqrt(self.T)
        b3 = (np.log(Smax/self.S0) + (self.r - self.q - self.sigma**2/2)*self.T)/(self.sigma*np.sqrt(self.T))
        Y2 = (2*(self.r - self.q- self.sigma**2/2)*np.log(Smax/self.S0))/self.sigma**2
            
        p = -self.S0*np.exp(-self.q*self.T)*N(b2)+ self.S0*np.exp(-self.q*self.T)*(self.sigma**2/(2*(self.r-self.q)))*N(-b2) + Smax*np.exp(-self.r*self.T)*(N(b1)-(self.sigma**2/(2*(self.r-self.q)))*np.exp(Y2)*N(-b3))
        return p
    ## -------------------------------------- BS floating ----------------------------------------- ##
    
    ## --------------------------------------- BS fixed ------------------------------------------- ##
    def fixed_BS_call_option_tree(self, Smax):
        N = norm.cdf
        
        SMAX = max(Smax, self.K)
        p = self.floating_BS_put_option_tree(SMAX)
        
        return p+self.S0*np.exp(-self.q*self.T)-self.K*np.exp(-self.r*self.T)
    
    def fixed_BS_put_option_tree(self, Smin):
        N = norm.cdf
        
        SMIN = min(Smin, self.K)
        c = self.floating_BS_call_option_tree(SMIN)
        
        return c+self.K*np.exp(-self.r*self.T)-self.S0*np.exp(-self.q*self.T)

    def cal_BS_put_option_delta(self, Smax):
        N = norm.cdf
        c1 = (np.log(self.S0/Smax) + (self.r + self.sigma**2/2)*self.T)/(self.sigma*np.sqrt(self.T))
        c2 = (np.log(Smax/self.S0) + (self.r - self.sigma**2/2)*self.T)/(self.sigma*np.sqrt(self.T))        
        delta = (1+self.sigma**2/(2*self.r))*N(c1)+(1-self.sigma**2/(2*self.r))*np.exp(-self.r*self.T)*(self.S0/Smax)**(-2*self.r/self.sigma**2)*N(-c2) - 1
    
        return delta

    def BS_generate_stockprice(self,So,n):
        St=So
        dt, u_ = 1/252, self.r-self.sigma**2/2
        for i in range(1,n+1):
            phi=np.random.normal(u_*dt,(self.sigma)*np.sqrt(dt),1)
            St=St*np.exp(phi)
            print(St)
            option
        


DataAnalysisPlot.py


import numpy as np
from scipy.stats import norm
import matplotlib.pyplot as plt
from pandas_datareader import data as pdr
from matplotlib import cm
from mpl_toolkits.mplot3d.axes3d import Axes3D

#<---- data extraction for parameter estimation

AMD_daily_price = pdr.get_data_yahoo("AMD", start="2020-05-03", end="2020-08-03", interval = 'd').dropna()['Adj Close']
AMD_daily_price = np.array(AMD_daily_price)
n= len(AMD_daily_price)
AMD_daily_return = np.array([np.log(AMD_daily_price[i+1]/AMD_daily_price[i]) for i in range(n-1)])
sigma=AMD_daily_return.std()*252**0.5

IRX_daily_rate = pdr.get_data_yahoo("^IRX", start="2020-05-03", end="2020-08-03", interval = 'd').dropna()['Adj Close']
IRX_daily_rate = np.array(IRX_daily_rate)
r=IRX_daily_rate.mean()

plt.plot(AMD_daily_price)
plt.xlabel('Days')
plt.ylabel('Stock Price')

plt.plot(IRX_daily_rate)
plt.xlabel('Days')
plt.ylabel('T-bill Interest Rate ^IRX')


#<--- 3D plot of theoretical Lookback Option Prices

def floating_put(T,S0,sigma,K,r,q):
    N = norm.cdf
    Smax=S0    
    
    ## the lookback option in our case has just been originated, so Smax = S0
    b1 = (np.log(Smax/S0) + (-r + q + sigma**2/2)*T)/(sigma*np.sqrt(T))
    b2 = b1 - sigma*np.sqrt(T)
    b3 = (np.log(Smax/S0) + (r - q - sigma**2/2)*T)/(sigma*np.sqrt(T))
    Y2 = (2*(r - q- sigma**2/2)*np.log(Smax/S0))/sigma**2
            
    p = -S0*np.exp(-q*T)*N(b2)+ S0*np.exp(-q*T)*(sigma**2/(2*(r-q)))*N(-b2) + Smax*np.exp(-r*T)*(N(b1)-(sigma**2/(2*(r-q)))*np.exp(Y2)*N(-b3))
    return p

def floating_call(T,S0,sigma,K,r,q):
    N = norm.cdf
    Smin=S0
        
    ## if the lookback option in our case has just been originated, so Smin = S0
    a1 = (np.log(S0/Smin) + (r - q + sigma**2/2)*T)/(sigma*np.sqrt(T))
    a2 = a1 - sigma*np.sqrt(T)
    a3 = (np.log(S0/Smin) + (-r + q + sigma**2/2)*T)/(sigma*np.sqrt(T))
    Y1 = -(2*(r - q- sigma**2/2)*np.log(S0/Smin))/sigma**2
        
    c = S0*np.exp(-q*T)*N(a1)- S0*np.exp(-q*T)*(sigma**2/(2*(r-q)))*N(-a1)-Smin*np.exp(-r*T)*(N(a2)-(sigma**2/(2*(r-q)))*np.exp(Y1)*N(-a3))
    return c

def fixed_call(T,S0,sigma,K,r,q):
    N = norm.cdf
    Smax=S0
        
    SMAX = np.maximum(Smax, K)
    p = floating_put(T,SMAX,sigma,K,r,q)
        
    return p+S0*np.exp(-q*T)-K*np.exp(-r*T)

def fixed_put(T,S0,sigma,K,r,q):
    N = norm.cdf
    Smin=S0
        
    SMIN = np.minimum(Smin, K)
    c = floating_call(T,SMIN,sigma,K,r,q)
        
    return c+K*np.exp(-r*T)-S0*np.exp(-q*T)


sigma=0.58
r=0.0012
S0=50
K=50
q=0

T=np.linspace(1,12,12)/12
S=np.linspace(S0,2*S0,S0)
Km=np.linspace(K,K,S0)
x,y =np.meshgrid(S,T)

fig=plt.figure(figsize=(8,6))
ax1=fig.add_subplot(221,projection='3d')
ax1.plot_surface(x,y,floating_put(y,x,sigma,K,r,q),rstride=2,cstride=2,cmap=cm.jet,alpha=0.7,linewidth=0.25)
ax1.set_xlabel('So')
ax1.set_ylabel('T')
ax1.set_zlabel('Option Price')
ax1.set_title('Floating Strike Put')

ax2=fig.add_subplot(222,projection='3d')
ax2.plot_surface(x,y,floating_call(y,x,sigma,K,r,q),rstride=2,cstride=2,cmap=cm.jet,alpha=0.7,linewidth=0.25)
ax2.set_xlabel('So')
ax2.set_ylabel('T')
ax2.set_zlabel('Option Price')
ax2.set_title('Floating Strike Call')

ax3=fig.add_subplot(223,projection='3d')
ax3.plot_surface(x,y,fixed_put(y,x,sigma,K,r,q),rstride=2,cstride=2,cmap=cm.jet,alpha=0.7,linewidth=0.25)
ax3.set_xlabel('So')
ax3.set_ylabel('T')
ax3.set_zlabel('Option Price')
ax3.set_title('Fixed Strike Put')

ax4=fig.add_subplot(224,projection='3d')
ax4.plot_surface(x,y,fixed_call(y,x,sigma,K,r,q),rstride=2,cstride=2,cmap=cm.jet,alpha=0.7,linewidth=0.25)
ax4.set_xlabel('So')
ax4.set_ylabel('T')
ax4.set_zlabel('Option Price')
ax4.set_title('Fixed Strike Call')

#<---- Hedging Analysis Results Plot

x=[51.33,52.07,54.44,51.09,49.98,51.61,50.63,48.79,45.74,45.71]
y_tree=[2.4551,2.444,2.6835,2.3738,2.4737,2.5344,2.4622,2.3616,2.191,2.1545]
y_theor=[0.00351,0.00629,0.00668,0.00423,0.00506,0.00267,0.00061,0.00613,-0.00222,0.00537]
plt.plot(y_tree,label='binomial tree values')
plt.plot(y_theor, label='theoretical values')
plt.xlabel('nth stock')
plt.ylabel('Hedged portfolio value')
plt.legend(loc='lower right')


 

















